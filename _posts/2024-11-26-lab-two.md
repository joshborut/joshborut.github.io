---
layout: post
title: There's no I in API (Lab 2)
subtitle: Tackling APIs with the help of Ms. Feng
cover-img: /assets/img/API_cover.png
thumbnail-img: /assets/img/API_thumbnail.png
share-img: /assets/img/API_cover.png
tags: [labs]
author: Joshua Borut
---

You put in your order and wait eagerly for your food, only to find that the waiter brings back a *JSON*! As it turns out, you accidentally requested from an __API__, which works much like a restaurant. In this lab, we explore API usage by querying ~The World Bank API~ (fancy!). Without further ado, let's get (js)on with the lab!

# 1. *Write a `CountryYear` class*

## Method
This portion of the assignment was quite straightforward; all I had to do was apply the basics of object oriented programming. This left me with the following:

```python
class CountryYear:
    def __init__(self, name, country_iso3, year, life_expectancy, gdp_per_capita, population, cereal_yield,
                 access_to_electricity, literacy_rate, inflation, undernourishment):
        self.name = name
        self.country_iso3 = country_iso3
        self.year = year
        self.life_expectancy = life_expectancy
        self.gdp_per_capita = gdp_per_capita
        self.population = population
        self.cereal_yield = cereal_yield
        self.access_to_electricity = access_to_electricity
        self.literacy_rate = literacy_rate
        self.inflation = inflation
        self.undernourishment = undernourishment
```

# 2. *Write a method get_world_bank_data(indicator) that queries the World Bank Indicators API*

## Method

As per usual when querying an API, I began by importing the requests library. Then, I used a formatted string literal to create the `api_url` concisely. I faced an issue where calling the endpoint did not provide all of the accessible data because the database is paginated with a default `per_page` value of 50. After playing around with the `per_page` query parameter, I found that the maximum entries is 32767. I was curious why this is the case so I googled the significance of the number and found that it is 2^15-1, which is apparently the maximum 16-bit signed integer--pretty cool ([Source](https://stackoverflow.com/questions/30653212/what-is-the-significance-of-the-number-32767))! After fixing this issue, I knew that I would get the maximum data coverage (hooray!). Once I called the API using the requests module, I proceeded to check the status code of the API to ensure that the data existed. If it did not, I returned `None`. Lastly, I simply turned the data into a JSON file and returned the result of the query, excluding the page formatting information which I circumvented using `data[1]` rather than simply `data`.

```python
def get_world_bank_data(indicator):
    # Per page
    api_url = f"https://api.worldbank.org/v2/country/all/indicator/{indicator}?format=json&per_page={2**15-1}"
    # Querying API
    api_call = requests.get(api_url)
    # Checking if the query is valid
    if api_call.status_code == 200:
        # converting api call into json
        data = api_call.json()
        return data[1]
    else:
        return None
```

I chose  __cereal yield__ (id: `AG.YLD.CREL.KG`), __access to electricity (% of population)__ (id: `EG.ELC.ACCS.ZS`), __litearcy rate of people 15-24__ (id: `SE.ADT.1524.LT.ZS`), __annual consumer price inflation__ (id: `FP.CPI.TOTL.ZG`), and __prevalence of undernourishment__ (id: `SN.ITK.DEFC.ZS`). I chose these five indicators because they give a general sense of a country's agriculture, economy, health, and infrastructure.

# 3. *Write a method that, based on all the world bank data, returns a list of `CountryYear` objects that has all your chosen indicators filled in*

## Method
Here is where things started to get a bit confusing. With the help of Ms. Feng, I realized that I'd have to use nested dictionaries to generate the list. I started by creating a function `get_indicator_data_dict(indicators)` that returns a nested dictionary with all the necessary data to create `CountryYear` objects. 

This function takes a list of indicators to query and begins by using list comprehension to store all of the different JSON data. Then, it loops through the JSONs, each of which corresponds to a specific type of indicator data. Within each JSON, it loops through each country-year entry and stores the relevant data in variables. Then, it uses the `get()` method to ensure that the relevant keys in the nested dictionary are populated such that an entry can be made. Once those checks are complete, it adds all of the country-year data stored in the aforementioned variables to the dictionary. 

```python
def get_indicator_data_dict(indicators):
    country_year_dict = {}

    # Creating list of JSONs from indicator data
    indicator_JSONs = [get_world_bank_data(indicator) for indicator in indicators]
    for indicator_JSON in indicator_JSONs:
        for country_data in indicator_JSON:
            # Saving the relevant data
            iso3_code = country_data['countryiso3code']
            country_name = country_data['country']['value']
            year = country_data['date']
            indicator = country_data['indicator']['id']
            indicator_value = country_data['value']

            # Ensuring that the relevant nested dictionaries exist
            country_year_dict[year] = country_year_dict.get(year, {})
            country_year_dict[year][iso3_code] = country_year_dict[year].get(iso3_code, {})

            # Adding the data to the nested dictionary
            country_year_dict[year][iso3_code]['name'] = country_name
            country_year_dict[year][iso3_code][indicator] = indicator_value
    return country_year_dict
```

The dictionary output of this function made writing `get_country_year_list()` far easier. This function simply iterates through all of the country-year pairs provided by the previously created function and appends the relevant data to the `CountryYear` list before returning the complete list.

```python
def get_country_year_list():
    country_year_list = []
    # Specifying the indicators
    indicators = ['SP.DYN.LE00.IN', 'NY.GDP.PCAP.CD', 'SP.POP.TOTL', 'AG.YLD.CREL.KG', 'EG.ELC.ACCS.ZS', 'SE.ADT.1524.LT.ZS', 'FP.CPI.TOTL.ZG', 'SN.ITK.DEFC.ZS']
    # Getting all the indicator data
    indicator_data_dict = get_indicator_data_dict(indicators)
    # Iterating through the country-year pairs
    for year in indicator_data_dict.keys():
        if int(year) < 1993:
            for iso_code3 in indicator_data_dict[year].keys():
                # TODO: Filter countries (TBD!)
                # Getting the data for a specific country-year pair
                country_data = indicator_data_dict[year][iso_code3]
                # Adding CountryYear object to list
                country_year_list.append(CountryYear(country_data['name'], iso_code3, year, country_data['SP.DYN.LE00.IN'], country_data['NY.GDP.PCAP.CD'], country_data['SP.POP.TOTL'], country_data['AG.YLD.CREL.KG'], country_data['EG.ELC.ACCS.ZS'], country_data['SE.ADT.1524.LT.ZS'], country_data['FP.CPI.TOTL.ZG'], country_data['SN.ITK.DEFC.ZS']))
    return country_year_list
    return country_year_list
```

## Failures (to learn from!)

Creating this function took a lot of trial and error. I initially tried to get every country iso3 code in a function `get_countries`, but that approach failed for two main reasons: (1) the World Bank Data API's [endpoint for all countries](https://api.worldbank.org/v2/country/all/) actually only has iso2 codes, which feels like quite an oversight, and (2) indicator data has regions listed in addition to countries, meaning that iterating only through countries would not account for all of the accessible data. My second approach was utilizing the multi-indicator functionality offered by the API, which you accomplish with a semicolon (e.g. AG.YLD.CREL.KG;EG.ELC.ACCS.ZS). I also considering using the `data` query parameter, but ultimately chose against it because it was easier to filter years in my own code. Admittedly, this may be slightly slower because it requires requesting more data, but I still found it easier. 

## Filtering

I chose not to filter the data much in terms of countries because I wanted to look globally. I may decide to focus on just one country per continent if I find looking at all of them too difficult, which should not be too difficult to implement in part 2 (I could simply add if statements checking if the data is from the desired countries or alter `api_url` in `get_world_bank_data` to use iso3 codes in a manner like `chn;bra` instead of `all`). However, I did exclude years after 1993 because I figured it would be interesting to analyze the indicators before the spread of the internet in 1993 ([Source](https://www.npr.org/2023/04/30/1172276538/world-wide-web-internet-anniversary#:~:text=Trump's%20Terms-,The%20World%20Wide%20Web%20became%20available%20to%20the%20broader%20public,with%20graphics%2C%20audio%20and%20hyperlinks.)).

# 4. *Print results from queries into a CSV*

## Method

I decided to utilize the `DictWriter` module because it would make writing to a file easier in my `create_country_years_csv(country_year_list)` function, which takes the output of the `get_indicator_data_dict(indicators)` method. I began by providing `DictWriter` the required headers and target file fields. Then, I wrote the header to the file and iterated through the provided `country_year_list` to write each entry to the CSV. I searched online and found that all classes have a `__dict__` attribute that returns a dictionary with the argument-value pairs of a specific object. This made using `writer.writerow()` far simpler.

```python
def create_country_years_csv(country_year_list):
    # Reference source for using DictWriter: https://docs.python.org/3/library/csv.html
    with open('country_years.csv', 'w', newline='') as f:
        fieldnames = ['name', 'country_iso3', 'year', 'life_expectancy', 'gdp_per_capita', 'population', 'cereal_yield', 'access_to_electricity', 'literacy_rate', 'inflation', 'undernourishment']
        writer = DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for country_year in country_year_list:
            # Reference source for using __dict__: https://stackoverflow.com/questions/61517/python-dictionary-from-an-objects-fields
            writer.writerow(country_year.__dict__)
```

# Bringing it all together!

Now, it was just a matter of calling the functions and creating the CSV. I felt like being fancy so I even added a `__main__` check!

```python
if __name__ == '__main__':
    country_year_list = get_country_year_list()
    create_country_years_csv(country_year_list)
```

## Takeaways

Although frustrating at some points, this lab was a good way to practice my API usage skills. I think I improved in terms of understanding documentation and using nested-dictionaries. I look forward to part 2! Thanks for all of the help Ms. Feng :)